"""
Vulnerability Scoring Algorithm
Analyzes family data to generate priority scores for resource allocation
"""

from typing import Dict, Tuple, List
from datetime import datetime, timedelta
import numpy as np
from dataclasses import dataclass


@dataclass
class ScoringWeights:
    """Weights for vulnerability factors"""
    economic: float = 40.0
    health: float = 30.0
    social: float = 20.0
    urgency: float = 10.0
    

class VulnerabilityScorer:
    """
    ML-based vulnerability scoring system for beneficiaries
    Factors:
    - Economic: Income vs. family size, employment status
    - Health: Medical visits, medication records, chronic conditions
    - Social: Housing conditions, migration status
    - Urgency: Time since last aid
    """
    
    def __init__(self, poverty_threshold: float = 200.0):
        """
        Initialize the scorer
        
        Args:
            poverty_threshold: Monthly income threshold to consider as living in poverty (in local currency)
        """
        self.poverty_threshold = poverty_threshold
        self.weights = ScoringWeights()
        self.housing_types = {
            'Propriétaire': 0.1,  # Owner - low risk
            'Locataire': 0.5,     # Renter - medium risk
            'Précaire': 1.0,      # Precarious - high risk
            None: 0.3              # Unknown - medium-low risk
        }
        self.social_status = {
            'Employé': 0.1,
            'Ouvrier': 0.2,
            'Indépendant': 0.3,
            'Retraité': 0.2,
            'Chômage': 1.0,
            'Autre': 0.5,
            None: 0.5
        }

    def calculate_economic_factor(
        self,
        monthly_income: float,
        family_members: int,
        social_status: str = None
    ) -> float:
        """
        Calculate economic vulnerability factor (0-40)
        
        Based on:
        - Per capita income
        - Employment status
        - Family size burden
        """
        income_per_capita = monthly_income / family_members if family_members > 0 else 0
        
        # Income-based scoring
        if income_per_capita <= (self.poverty_threshold / 2):
            income_score = 40.0
        elif income_per_capita <= self.poverty_threshold:
            income_score = 30.0 + (monthly_income / self.poverty_threshold) * 10
        elif income_per_capita <= self.poverty_threshold * 1.5:
            income_score = 20.0
        else:
            income_score = max(0, 10.0 - (income_per_capita - self.poverty_threshold * 1.5) / 50)
        
        # Social status multiplier
        status_multiplier = self.social_status.get(social_status, 0.5)
        
        # Family size burden (larger families need more resources)
        size_factor = 1.0 + (max(0, family_members - 2) * 0.1)
        
        economic_factor = min(self.weights.economic, income_score * status_multiplier * size_factor)
        return round(float(economic_factor), 2)

    def calculate_health_factor(
        self,
        medical_visits_count: int,
        medication_records_count: int,
        health_conditions: str = None,
        dependents_with_needs: int = 0
    ) -> float:
        """
        Calculate health vulnerability factor (0-30)
        
        Based on:
        - Frequency of medical visits
        - Medication requirements
        - Presence of chronic conditions
        - Number of dependents needing care
        """
        health_factor = 0.0
        
        # Medical visits frequency (0-15 points)
        if medical_visits_count > 10:
            visit_score = 15.0  # Chronic condition or frequent illnesses
        elif medical_visits_count > 5:
            visit_score = 10.0
        elif medical_visits_count > 2:
            visit_score = 5.0
        else:
            visit_score = 0.0
        
        # Medication requirements (0-10 points)
        if medication_records_count > 5:
            medication_score = 10.0
        elif medication_records_count > 2:
            medication_score = 5.0
        else:
            medication_score = 0.0
        
        # Health conditions presence (0-10 points)
        condition_score = 0.0
        if health_conditions:
            conditions_list = health_conditions.lower()
            # High-risk conditions
            high_risk = ['cancer', 'diabète', 'hypertension', 'tuberculose', 'vih', 'hiv']
            if any(condition in conditions_list for condition in high_risk):
                condition_score = 10.0
            else:
                condition_score = 5.0
        
        # Dependent care burden (0-5 points)
        dependent_score = min(5.0, dependents_with_needs * 2)
        
        health_factor = min(
            self.weights.health,
            visit_score + medication_score + condition_score + dependent_score
        )
        
        return round(float(health_factor), 2)

    def calculate_social_factor(
        self,
        housing_type: str = None,
        migration_status: str = None,
        elderly_count: int = 0,
        disabled_count: int = 0,
        children_count: int = 0
    ) -> float:
        """
        Calculate social vulnerability factor (0-20)
        
        Based on:
        - Housing conditions
        - Migration/displacement status
        - Vulnerable dependents (elderly, disabled, children)
        """
        social_factor = 0.0
        
        # Housing conditions (0-10 points)
        housing_score = self.housing_types.get(housing_type, 0.3) * 10
        
        # Migration status (0-5 points)
        migration_factor = {
            'External': 5.0,      # Refugee/migrant
            'Internal': 3.0,      # Internal displacement
            'Returnee': 2.0,      # Recently returned
            'None': 0.0,
            None: 0.0
        }
        migration_score = migration_factor.get(migration_status, 0.0)
        
        # Vulnerable dependents (0-5 points)
        vulnerable_count = elderly_count + disabled_count
        children_factor = min(children_count * 0.5, 2.0)  # Max 2 points for children
        dependent_score = min(5.0, vulnerable_count * 1.5 + children_factor)
        
        social_factor = min(
            self.weights.social,
            housing_score + migration_score + dependent_score
        )
        
        return round(float(social_factor), 2)

    def calculate_urgency_factor(
        self,
        last_aid_date: datetime = None,
        days_threshold: int = 90
    ) -> float:
        """
        Calculate urgency factor (0-10)
        
        Based on time since last aid was provided
        """
        urgency_factor = 0.0
        
        if last_aid_date is None:
            # Never received aid - maximum urgency
            urgency_factor = self.weights.urgency
        else:
            days_since_aid = (datetime.utcnow() - last_aid_date).days
            
            if days_since_aid > days_threshold * 2:
                urgency_factor = self.weights.urgency  # 10 points
            elif days_since_aid > days_threshold:
                urgency_factor = 7.0
            elif days_since_aid > days_threshold / 2:
                urgency_factor = 4.0
            else:
                urgency_factor = 0.0
        
        return round(float(urgency_factor), 2)

    def get_risk_level(self, score: float) -> str:
        """Classify risk level based on score"""
        if score >= 80:
            return "CRITICAL"
        elif score >= 60:
            return "HIGH"
        elif score >= 40:
            return "MEDIUM"
        else:
            return "LOW"

    def get_recommendations(
        self,
        risk_level: str,
        economic_factor: float,
        health_factor: float,
        social_factor: float,
        urgency_factor: float,
        family_members: int,
        children_count: int,
        elderly_count: int
    ) -> List[str]:
        """Generate recommendations based on vulnerability factors"""
        recommendations = []
        
        # Priority-based recommendations
        if risk_level == "CRITICAL":
            recommendations.append("URGENT: Prioritize for immediate assistance")
        
        # Economic recommendations
        if economic_factor >= 30:
            recommendations.append("Income Support: Provide financial assistance or employment support")
        
        # Health recommendations
        if health_factor >= 20:
            recommendations.append("Healthcare: Schedule medical assessment and provide medication support")
        elif health_factor >= 10:
            recommendations.append("Healthcare: Provide preventive health services")
        
        # Social recommendations
        if social_factor >= 15:
            recommendations.append("Housing: Assess and support housing needs")
        
        # Family-specific recommendations
        if children_count > 2:
            recommendations.append("Child Support: Educational and nutritional support for children")
        
        if elderly_count > 0:
            recommendations.append("Elderly Care: Provide elder-specific social services")
        
        if urgency_factor >= 7:
            recommendations.append("Follow-up: Schedule urgent follow-up visit within 2 weeks")
        
        return recommendations if recommendations else ["Standard monitoring and annual review"]

    def calculate_score(self, beneficiary_data: Dict) -> Dict:
        """
        Calculate complete vulnerability score for a beneficiary
        
        Args:
            beneficiary_data: Dictionary containing beneficiary information
            
        Returns:
            Dictionary with all vulnerability scores and recommendations
        """
        # Extract data with defaults
        monthly_income = float(beneficiary_data.get('revenuMensuel') or 0)
        family_members = int(beneficiary_data.get('nbMembres') or 1)
        children = int(beneficiary_data.get('nbEnfants') or 0)
        elderly = int(beneficiary_data.get('nbPersonnesAgees') or 0)
        disabled = int(beneficiary_data.get('nbHandicapes') or 0)
        housing_type = beneficiary_data.get('typeLogement')
        social_status = beneficiary_data.get('statutSocial')
        migration_status = beneficiary_data.get('migrationStatus')
        health_conditions = beneficiary_data.get('healthConditions')
        medical_visits = int(beneficiary_data.get('medicalVisitsCount') or 0)
        medication_records = int(beneficiary_data.get('medicationRecordsCount') or 0)
        last_aid_date = beneficiary_data.get('lastAidDistributionDate')
        
        # Parse last_aid_date if it's a string
        if isinstance(last_aid_date, str):
            try:
                last_aid_date = datetime.fromisoformat(last_aid_date.replace('Z', '+00:00'))
            except:
                last_aid_date = None
        
        # Calculate individual factors
        economic = self.calculate_economic_factor(
            monthly_income,
            family_members,
            social_status
        )
        
        health = self.calculate_health_factor(
            medical_visits,
            medication_records,
            health_conditions,
            elderly + disabled + children
        )
        
        social = self.calculate_social_factor(
            housing_type,
            migration_status,
            elderly,
            disabled,
            children
        )
        
        urgency = self.calculate_urgency_factor(last_aid_date)
        
        # Calculate total vulnerability score
        total_score = economic + health + social + urgency
        
        risk_level = self.get_risk_level(total_score)
        
        recommendations = self.get_recommendations(
            risk_level,
            economic,
            health,
            social,
            urgency,
            family_members,
            children,
            elderly
        )

        # Logic for Feature Contributions
        contributions = [
            {"feature": "Statut Économique", "value": economic, "max_possible": 40},
            {"feature": "Besoins Santé", "value": health, "max_possible": 30},
            {"feature": "Facteurs Sociaux (Logement/Réfugié)", "value": social, "max_possible": 20},
            {"feature": "Urgence Chronologique", "value": urgency, "max_possible": 10}
        ]
        # Sort by impact
        contributions = sorted(contributions, key=lambda x: x['value'], reverse=True)

        # Logic for Confidence Score (Data Completeness)
        vital_fields = ['revenuMensuel', 'typeLogement', 'nbMembres', 'healthConditions']
        filled_vitals = sum(1 for field in vital_fields if beneficiary_data.get(field) is not None)
        confidence = filled_vitals / len(vital_fields)
        
        return {
            'vulnerabilityScore': round(float(total_score), 2),
            'economicFactor': economic,
            'healthFactor': health,
            'socialFactor': social,
            'urgencyFactor': urgency,
            'riskLevel': risk_level,
            'recommendations': recommendations,
            'featureContributions': contributions,
            'confidenceScore': round(float(confidence), 2)
        }
